#!/usr/bin/env python

import os, sys
import subprocess

def debug(text):
    print("------>>>  " + str(text))
    
    
class NotImplementedException(Exception):
    pass

class AB:
    """AlienBrain command line tool wrapper, to get data easier with scripting,
    The API design will mimic the ones of Perforce, see: 'Perforce 2009.1 APIs 
    for Scripting' """
    # Q: is it a good way to parse stdout, stderr?
    
    # 'long  => short' command name mapping, used in checking or validation
    AB_CMDS = { }
    
    VALID_ARGS = ("get")
    
    session = None  # obj must have sth. to record.
    auto_reconnect = True
    
    def __init__(self, executable):
        self.executable =  executable
        # TODO: check version info
        self.args = []
        self.output = ""
    
    def getworkingpath(self):
        self.args = []
        self.args.extend("getworkingpath")
        self.call()
        return self.output
    
#    def call(self):
#        self.output = os.popen(self.executable + " " + " ".join(self.args) ).read()
#        return self.output
        
        
    # ESP.TODO: use meta programming to generate commands from syntax knowledge,
    # e.g. getworkingpath call should be validated and sent to msg receiver.
    
#    def cmd(self, cmd_string):
#        """ simply get stdout and stderr from executing a commandline, it seems the result
#        parsing should be done by the each caller."""
#        proc = subprocess.Popen(cmd_string,
#                        shell=True,
#                        stdin=subprocess.PIPE,
#                        stdout=subprocess.PIPE,
#                        stderr=subprocess.PIPE,
#                        )
#        
#        stdout_value, stderr_value = proc.communicate()
#        print(stdout_value + " <<<= stdout")
#        print(stderr_value + " <<<= stderr")
        
    # Q: how to get output and return value simultaneously
    def call(self, cmd_string):
        """"""
        debug(cmd_string)
        retcode = subprocess.call(cmd_string, shell=True)
        debug("return code " + str(retcode))
        debug(repr(sys.stdout)) 
        debug(repr(sys.stderr))
        return (retcode, sys.stdout, sys.stderr)
        
    # damned, it should be generated from documentation or self-help.
    def logon(self, username, password, project, ab_server):
        cmd_str = " ".join(['ab', 'logon','-u', username, '-p',password, '-d', project, '-s', ab_server])
        self.call(cmd_str)
    
    def logoff(self): 
        cmd_str = " ".join(['ab','logoff'])
        self.call(cmd_str)
        
    def connected(self):
        cmd_str = " ".join(['ab','ic'])
        self.call(cmd_str)
    
    def setworkingpath(self,dir):
        #TODO: avoid blankspace and slash '\'
        cmd_str = " ".join(['ab','getworkingpath',dir])
        self.call(cmd_str)    
        
    def submit_file(self,file):    
        pass
#if __name__ == '__main__':
#    ab = AB("C:\Program Files (x86)\alienbrain\Client\Application\Tools\ab.exe")
#    print(ab.getworkingpath())

# ESP. COMMMANDS

## log on
#ab logon -u Administrator -p "mes0Spicy" -d p4mirror -s Spicyfile


## setup ab local workspace, ready to import changeSet
#ab -


## add file
#ab 



#Usage Examples:
#---------------
#ab help checkout
#ab h gl
#ab enumprojects -s NXNSERVER
#ab logon -u John -p "" -d Demo_Project -s NXNSERVER
#ab setworkingpath "c:\myworkingpath\Demo_Project"
#ab enumobjects
#ab isuptodate picture1.bmp
#ab find -checkedoutby "John"
#ab checkout picture1.bmp -comment "Modifying background" -response:CheckOut.Writ
#able y
#ab logoff

import P4
import os
from operator import itemgetter
import operator


#TODO: logging

p4env = {
    'port':'localhost:1666',
    'user':'ZhuJiaCheng',
    'passwd':'',
    'client':'ZhuJiaCheng_test_specify_p4_env',
    'branch':'',
    'charset':'',
    'customview':'''View:
    //depot/Alice2_Prog/Development/... //%client%/Development/...
    +//depot/Alice2_Prog/Tools/... //%client%/Tools/...
    +//depot/Alice2_Bin/PC_Dependencies/... //%client%/PC_Dependencies/...
    +//depot/Alice2_Bin/Binaries/... //%client%/Binaries/...
    +//depot/Alice2_Bin/Engine/... //%client%/Engine/...
    +//depot/Alice2_Bin/AliceGame/... //%client%/AliceGame/...
    +//depot/Alice2_Bin/*.* //%client%/*.*
    +//depot/Alice2_Branches/... //%client%/Alice2_Branches/...
''',
    # depre: 'workspace' : 'Admin_spicyfile_1666_NightlySlave',  # => buildbot auto-generated by rules
    }


p4 = P4.P4()
#ab = AB.AB()




def p4_init():

    p4.client = p4env['client']
    p4.port = p4env['port']
    p4.user = p4env['user']
    p4.password = p4env['passwd']
    #p4.charset = p4env['charset']
    #TODO: lock format by setting API level!!!
    p4.exception_level = 1 # ignore "File(s) up-to-date"
    if not p4.connected(): p4.connect() 
    return p4
#    except P4Exception:
#        for e in p4.errors:
#            print e
#    finally:
#        p4.disconnect()
        
def change_workdir(dir):
    """ change to the desired the directory for migration, in case of
    any undesired default directory."""
    p4 = p4_init()
    clientspec = p4.fetch_client()
    if os.path.exists(dir):
        clientspec['Root'] = dir
    p4.save_client(clientspec)  


def p4_get_changes():
    p4 = p4_init() 
    changes = []
    
    # TODO: see if need to get branch related changelist, it looks like 
    #  for a2, no way to get changelists from branch info.
    try:
        changes = p4.run('changes', '-t', '-l')
    except P4Exception:
        for e in p4.errors:
            print e
            debug(e)
        #TODO: log here

    deco = [( int(change['change']), change) for change in changes ]
    deco.sort()
    changes = [ change for (key, change) in deco]
    debug(changes[0].__class__)
    debug(changes[0])
    debug(changes[1])
    debug(changes[0]['desc'])
    debug(changes[0]['time'])
    debug(changes[0].keys())
    
    return changes
    

def ab_submit_change():
    """submit changes on the workspace after calling an p4 sync"""
    #TODO: sanity check to prevent the interrupted one or duplicated one! 
    #TODO: ??make it atomic? rollback ab's change if not fulfilled.    
    
    
    
    
if __name__ == '__main__':   
    # ---------------------- p4 sandbox
    #p4_get_changes()[0]
    
    #change_workdir("D:/p4migtest")
    #p4.run_sync("//depot/...@%s" % "1" )
    # -----------------------  ab sandbox
    
    ab = AB("C:/Program Files (x86)/alienbrain/Client/Application/Tools/ab.exe")
    
    ab.logon("Administrator", "mes0Spicy", "p4migtest ", "Spicyfile")
    ab.connected()
    ab.logoff()
    ab.connected()