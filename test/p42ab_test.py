

import unittest
import sys
import re
import fnmatch

sys.path.append("../src")
from p42ab import AlienBrainCLIWrapper, MigrationWorker, P4PYAPIWrapper, P4PORT,P4USER,P4PASSWORD,P4CLIENT

# Q: Should test functions groups into class? It' tedious to add/remove 'self' argument
#    when converting to class or to non-class.
# A: class is necessary, we have to inheret  


p4env = {
    'port': P4PORT,
    'user': P4USER,
    'passwd': P4PASSWORD,
    'client':'ZhuJiaCheng_test_specify_p4_env',
    'branch':'',
    'charset':'',
    #'customview':'''View:
    'view':'''
     //depot/Alice2_Prog/Development/... //ZhuJiaCheng_test_specify_p4_env/Development/...
    +//depot/Alice2_Prog/Tools/... //ZhuJiaCheng_test_specify_p4_env/Tools/...
    +//depot/Alice2_Bin/PC_Dependencies/... //ZhuJiaCheng_test_specify_p4_env/PC_Dependencies/...
    +//depot/Alice2_Bin/Binaries/... //ZhuJiaCheng_test_specify_p4_env/Binaries/...
    +//depot/Alice2_Bin/Engine/... //ZhuJiaCheng_test_specify_p4_env/Engine/...
    +//depot/Alice2_Bin/AliceGame/... //ZhuJiaCheng_test_specify_p4_env/AliceGame/...
    +//depot/Alice2_Bin/*.* //ZhuJiaCheng_test_specify_p4_env/*.*
    +//depot/Alice2_Branches/... //ZhuJiaCheng_test_specify_p4_env/Alice2_Branches/...
''',
    # depre: 'workspace' : 'Admin_spicyfile_1666_NightlySlave',  # => buildbot auto-generated by rules
    }


    # //depot/... //ZhuJiaCheng_test_specify_p4_env/...

workspace_basedir="somewhere.on.disk"

class AlienBrainCLIWrapperTest(unittest.TestCase):


    def setUp(self):
        self.ab_agent = AlienBrainCLIWrapper()

#    def test_workspace_dir(self):
#        """Because the depot/workspace mapping in the view of 'p4 workspace' may have multiple entries, 
#        and also it's important for Alienbrain's workspace to get files/directory absolutely correct( in
#        order to mirror the p4 server), we test to make sure the function is OK under any circumstances. 
#        
#        @see: AlienBrainCLIWrapperTest#workspace_dir(self, workspace_basedir, a_depot_path, view)
#        """
#        a_depot_path="//depot/Alice2_Prog/Tools/a.txt"
#        output = self.ab_agent.workspace_dir(workspace_basedir, a_depot_path, p4env )
#        expect = "somewhere.on.disk/Alice2_Prog/Tools/a.txt"
#        self.assertEqual( output, expect)
        
    
    def test_p4view_mapping_wont_duplicate_key(self):
        "To make sure that the mappings(for locating the absolute path for AlienBrain) is correct!"
        
        #
        dict_with_view_key = {
                'view':'''
                    //depot/somedir/*.txt //workspace_name/otherdir/*.txt
                    +//depot/somedir/*.doc //workspace_name/otherdir/*.doc
                '''              
                     }
#        output = self.ab_agent.workspace_dir(workspace_basedir, workspace_basedir, dict_with_view_key )
#        expect = { "//depot/some dir" : "//workspace_name/otherdir/" }
#        self.assertEqual( output , expect)
    
    def test_p4view_mapping_has_spaces_in_dir(self):
        pass
    
    
    def test_parse_p4_view_map(self):
        
        dict_with_view_key = {
                'view':'''
                    //depot/somedir/*.txt //workspace_name/otherdir/*.txt
                    +//depot/somedir/*.doc //workspace_name/otherdir/*.doc
                '''              
                     }
        output = self.ab_agent.parse_p4_view_map( dict_with_view_key )
        expect = { "//depot/somedir" : "//workspace_name/otherdir" }
        self.assertEqual( output , expect)
    
    
    def test_python_wildcard_matching(self):
        'for p4 workspace view mapping matching'
        
        string = "aa/bb/cc/a.txt"
        pattern = "aa/bb/cc/*\.txt"
        result =  re.search(pattern, string)
       # self.assertTrue( result != None )
#        pat = re.compile("aa/bb/cc/*.txt", flags)
#        pat_mix = "aa/bb/cc/*.txt"
#        pattern = re.co
        
    def test_python_wildcard_matching_using_fnmatch(self):
        'for p4 workspace view mapping matching'
        
        # Notes: 
        # * fnmatch(http://docs.python.org/library/fnmatch.html) gives some hints, but can not be used here,
        #   because we may do part matching, while "$" in fnmatch causes troubles and also we can not open the fnmatch to customize.
          
        # ---------   python regex matching experiment  -----------
        # TODO: generate the pattern from a string of directory
        pattern_file = "^aa\/bb\/cc\/[^\/]\.txt$"   # why using []
        pattern_dir  = "^dir1\/dir\/dir1" 
        
        
        # simple match
        string = "aa/bb/cc/a.txt"
        result = re.match(pattern_file, string)
        self.assertTrue( result != None )
        print result
        print result.group()
        print help(result.group)
        
        # should not match  directory
        string = "aa/bb/cc/a/b.txt"  # more directories
        result = re.match(pattern_file, string)
        self.assertTrue( result == None, "The string contains another directoy, so it failed!")
        
        # if no files match found, prepare directory matching.
        string = "aa/bb/cc/a/..."
    
    def _format_view_key_to_pattern(self, string):
            return "^"+string.replace("/","\\/").replace("...",".*")+"$"     
        
    def test_format_view_key_to_pattern(self):
        """ to convert a p4workspace's //depot directory into a pattern for later search """    
        
        
        
        a = "//depot/directory/a.txt"
        a_pat = "^\/\/depot\/directory\/a.txt$"
        # make sure pattern can be used to check
        result = re.match(a_pat, a)
        self.assertTrue( result != None )
        # make sure the pattern is what we need.
        self.assertEqual( self._format_view_key_to_pattern(a), a_pat )
        
        a = "//depot/directory/..."
        # although the pattern can match the 'a.txt', but we use other function to choose the best suitable one, 
        # see: _get_p4_view_key
        a_pat = "^\/\/depot\/directory\/.*$" 
        # make sure the pattern is what we need.
        self.assertEqual( self._format_view_key_to_pattern(a), a_pat )

        # Q: Any possible the strange pattern of p4workspace view key?
        
        
    
    # Q: Since this test depends on test_format_view_key_to_pattern, is there any practice 
    #    like annotation or other coding techniques to make sure the dependent ones are OK? 
    def test_single_match(self):
        """Given one file, it should only match a single entry of p4workspace's //depot path,
        if //depot path is a file path, if exact entry not found, fall back to a //depot parent path search.
        """
        
        a_depot_path = "//depot/directory/a.txt"
        a_depot_path2 = "//depot/directory/b.txt"
        a_depot_path3 = "//depot/c.txt"
        a_depot_path_invalid = "//invalid/depot/path"
        depot_view_keys = [ "//depot/directory/...",
                            "//depot/a.txt", 
                            "//depot/directory/a.txt",
                            "//depot/..." # any depot path should fall onto this entry if no other entry matched.    
                            ]
        
        # TODO: move to AlienBrainCLIWrapper or Util class!
        def _get_p4_view_key(depot_path, depot_view_keys):
            """find the most suitable depot_view_keys acoording to a depot path"""
            
            
            
            
            return 
        
        # a_depot_path should find depot_view_keys[2]                   
        self.assertEqual( _get_p4_view_key(a_depot_path) , depot_view_keys[2] )    
        
        # a_depot_path2 should find depot_view_keys[0]   
        self.assertEqual( _get_p4_view_key(a_depot_path2) , depot_view_keys[0] ) 
        
        # a_depot_path3 should find depot_view_keys[3]
        self.assertEqual( _get_p4_view_key(a_depot_path3) , depot_view_keys[3] )    
        
        # a_depot_path_invalid should not find any  depot_view_keys  
        self.assertEqual( _get_p4_view_key(a_depot_path_invalid) , None ) 
    
    
#        view_key = ""
#        self.ab_agent.format_view_key_to_pattern()
        
#        print result
#        print result.group()
#        print help(result.group)
#        pat = re.compile("aa/bb/cc/*.txt", flags)
#        pat_mix = "aa/bb/cc/*.txt"
#        pattern = re.co
        
        
if __name__ == '__main__':   
    unittest.main()
print "ended "



