

import unittest
import os, sys
import re
import fnmatch

sys.path.append("../src")
from p42ab import AlienBrainCLIWrapper, MigrationWorker, P4PYAPIWrapper, P4PORT,P4USER,P4PASSWORD,P4CLIENT

# Q: Should test functions groups into class? It' tedious to add/remove 'self' argument
#    when converting to class or to non-class.
# A: class is necessary, we have to inheret  


p4env = {
    'port': P4PORT,
    'user': P4USER,
    'passwd': P4PASSWORD,
    'client':'ZhuJiaCheng_test_specify_p4_env',
    'branch':'',
    'charset':'',
    #'customview':'''View:
    'view':'''
     //depot/Alice2_Prog/Development/... //ZhuJiaCheng_test_specify_p4_env/Development/...
    +//depot/Alice2_Prog/Tools/... //ZhuJiaCheng_test_specify_p4_env/Tools/...
    +//depot/Alice2_Bin/PC_Dependencies/... //ZhuJiaCheng_test_specify_p4_env/PC_Dependencies/...
    +//depot/Alice2_Bin/Binaries/... //ZhuJiaCheng_test_specify_p4_env/Binaries/...
    +//depot/Alice2_Bin/Engine/... //ZhuJiaCheng_test_specify_p4_env/Engine/...
    +//depot/Alice2_Bin/AliceGame/... //ZhuJiaCheng_test_specify_p4_env/AliceGame/...
    +//depot/Alice2_Bin/*.* //ZhuJiaCheng_test_specify_p4_env/*.*
    +//depot/Alice2_Branches/... //ZhuJiaCheng_test_specify_p4_env/Alice2_Branches/...
''',
    # depre: 'workspace' : 'Admin_spicyfile_1666_NightlySlave',  # => buildbot auto-generated by rules
    }


    # //depot/... //ZhuJiaCheng_test_specify_p4_env/...

workspace_basedir="somewhere.on.disk"

class AlienBrainCLIWrapperTest(unittest.TestCase):


    def setUp(self):
        self.ab_agent = AlienBrainCLIWrapper()

#    def test_workspace_dir(self):
#        """Because the depot/workspace mapping in the view of 'p4 workspace' may have multiple entries, 
#        and also it's important for Alienbrain's workspace to get files/directory absolutely correct( in
#        order to mirror the p4 server), we test to make sure the function is OK under any circumstances. 
#        
#        @see: AlienBrainCLIWrapperTest#workspace_dir(self, workspace_basedir, a_depot_path, view)
#        """
#        a_depot_path="//depot/Alice2_Prog/Tools/a.txt"
#        output = self.ab_agent.workspace_dir(workspace_basedir, a_depot_path, p4env )
#        expect = "somewhere.on.disk/Alice2_Prog/Tools/a.txt"
#        self.assertEqual( output, expect)
        
    
    def test_p4view_mapping_wont_duplicate_key(self):
        "To make sure that the mappings(for locating the absolute path for AlienBrain) is correct!"
        
        #
        dict_with_view_key = {
                'view':'''
                    //depot/somedir/*.txt //workspace_name/otherdir/*.txt
                    +//depot/somedir/*.doc //workspace_name/otherdir/*.doc
                '''              
                     }
#        output = self.ab_agent.workspace_dir(workspace_basedir, workspace_basedir, dict_with_view_key )
#        expect = { "//depot/some dir" : "//workspace_name/otherdir/" }
#        self.assertEqual( output , expect)
    
    def test_p4view_mapping_has_spaces_in_dir(self):
        pass
    
    
    def test_parse_p4_view_map(self):
        
        dict_with_view_key = {
                'view':'''
                    //depot/somedir/*.txt //workspace_name/otherdir/*.txt
                    +//depot/somedir/*.doc //workspace_name/otherdir/*.doc
                '''              
                     }
        output = self.ab_agent.parse_p4_view_map( dict_with_view_key )
        expect = { "//depot/somedir" : "//workspace_name/otherdir" }
        self.assertEqual( output , expect)
    
    
    def test_python_wildcard_matching(self):
        'for p4 workspace view mapping matching'
        
        string = "aa/bb/cc/a.txt"
        pattern = "aa/bb/cc/*\.txt"
        result =  re.search(pattern, string)
       # self.assertTrue( result != None )
#        pat = re.compile("aa/bb/cc/*.txt", flags)
#        pat_mix = "aa/bb/cc/*.txt"
#        pattern = re.co
        
    def test_python_wildcard_matching_using_fnmatch(self):
        'for p4 workspace view mapping matching'
        
        # Notes: 
        # * fnmatch(http://docs.python.org/library/fnmatch.html) gives some hints, but can not be used here,
        #   because we may do part matching, while "$" in fnmatch causes troubles and also we can not open the fnmatch to customize.
          
        # ---------   python regex matching experiment  -----------
        # TODO: generate the pattern from a string of directory
        pattern_file = "^aa\/bb\/cc\/[^\/]\.txt$"   # TODO: missing * after ] ?
        pattern_dir  = "^dir1\/dir\/dir1" 
        
        
        # simple match
        string = "aa/bb/cc/a.txt"
        result = re.match(pattern_file, string)
        self.assertTrue( result != None )
        print result
        print result.group()
        print help(result.group)
        
        # should not match  directory
        string = "aa/bb/cc/a/b.txt"  # more directories
        result = re.match(pattern_file, string)
        self.assertTrue( result == None, "The string contains another directoy, so it failed!")
        
        # if no files match found, prepare directory matching.
        string = "aa/bb/cc/a/..."
    
     
        
    def test_format_view_key_to_pattern(self):
        
        a = "//depot/directory/a.txt"
        a_pat = "^\/\/depot\/directory\/a.txt$"
        # make sure pattern can be used to check
        result = re.match(a_pat, a)
        self.assertTrue( result != None )
        # make sure the pattern is what we need.
        self.assertEqual( self.ab_agent.format_view_key_to_pattern(a), a_pat )
        
        a = "//depot/directory/..."
        # although the pattern can match the 'a.txt', but we use other function to choose the best suitable one, 
        # see: _get_p4_view_key
        a_pat = "^\/\/depot\/directory\/.*$" 
        # make sure the pattern is what we need.
        self.assertEqual( self.ab_agent.format_view_key_to_pattern(a), a_pat )
        
        
        a = "//depot/directory/*.*"
        a_file = "//depot/directory/ccc.doc"
        a_pat = "^\/\/depot\/directory\/[^\/]*\.[^\/]*$"
        # make sure pattern can be used to check
        result = re.match(a_pat, a_file)
        self.assertTrue( result != None )
        # make sure the pattern is what we need.
        self.assertEqual( self.ab_agent.format_view_key_to_pattern(a), a_pat )

        # Q: Any possible the strange pattern of p4workspace view key?
        
      
    
    # Q: Since this test depends on test_format_view_key_to_pattern, is there any practice 
    #    like annotation or other coding techniques to make sure the dependent ones are OK? 
    def test_single_best_match(self):
        """Given one file, it should only match a single entry of p4workspace's //depot path,
        if //depot path is a file path, if exact entry not found, fall back to a //depot parent path search.
        """
        
        a_depot_path1 = "//depot/directory/a.txt"
        a_depot_path11 = "//depot/directorya.txt"
        a_depot_path2 = "//depot/directory/b.txt"
        a_depot_path3 = "//depot/c.txt"
        a_depot_path4 = "//depot/a"         # should best match to "//depot/a", not ""//depot/...""
        a_depot_path5 = "//depot/directory/.*"  #
        a_depot_path_invalid = "//invalid/depot/path"
        # ESP. do NOT change the sequence of the key, only add entry at the end of the list.
        depot_view_keys = [ "//depot/directory/...",
                            "//depot/a.txt",   
                            "//depot/directory/a.txt",
                            "//depot/...",  # any depot path should fall onto this entry if no other entry matched.
                            "//depot/a",     # test out with "//depot/...", making sure key for the 'a_depot_path4' won't fall back to "//depot/..." 
                            "//depot/*.*",    # should best match over "//depot/..." if meets a file
                            # anticipate more cases! List the un-handled ones below.
                            ]
        
        # a_depot_path1 should match depot_view_keys[2]
        self.assertTrue( re.match( self.ab_agent.format_view_key_to_pattern("//depot/directory/..." ), a_depot_path1) )                   
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path1, depot_view_keys) , "//depot/directory/a.txt" )    
        
        # a_depot_path11 should have two candidates, but still a single best match.
        self.assertTrue( re.match( self.ab_agent.format_view_key_to_pattern("//depot/..." ), a_depot_path11) )
        self.assertTrue( re.match( self.ab_agent.format_view_key_to_pattern("//depot/*.*" ), a_depot_path11) )
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path11, depot_view_keys) , "//depot/*.*"  )
        
        # a_depot_path2 should match depot_view_keys[0]   
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path2, depot_view_keys) , "//depot/directory/..." ) 
        
        # a_depot_path3 should match depot_view_keys[3]
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path3, depot_view_keys) , "//depot/*.*" )
        self.assertNotEqual( self.ab_agent.get_single_best_match(a_depot_path3, depot_view_keys) , "//depot/..." )        
        
        # a_depot_path_invalid should not find any  depot_view_keys  
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path_invalid, depot_view_keys) , None ) 
    
        # a_depot_path4 should match depot_view_keys[4], nor [3] or [5]
        self.assertEqual( self.ab_agent.get_single_best_match(a_depot_path4, depot_view_keys) , "//depot/a" , 
                          "expl., for depot path '%s', it prefers '%s' to '%s', '%s'." % ( "//depot/a", "//depot/a" , "//depot/..." ,"//depot/*.*" ))
        self.assertNotEqual( self.ab_agent.get_single_best_match(a_depot_path4, depot_view_keys) , "//depot/..." )
        self.assertNotEqual( self.ab_agent.get_single_best_match(a_depot_path4, depot_view_keys) , "//depot/*.*" )


#        view_key = ""
#        self.ab_agent.format_view_key_to_pattern()
        
#        print result
#        print result.group()
#        print help(result.group)     
#        pat = re.compile("aa/bb/cc/*.txt", flags)
#        pat_mix = "aa/bb/cc/*.txt"
#        pattern = re.co
        
        
    def test_parse_p4_view_map(self):
        """
        See also:  AlienBrainCLIWrapper#parse_p4_view_map
        """
        a_view = { "view" : """
            //depot/Alice2_Prog/Development/... //ZhuJiaCheng_test_specify_p4_env/Development/...
            +//depot/Alice2_Prog/Tools/... //ZhuJiaCheng_test_specify_p4_env/Tools/...
            +//depot/Alice2_Bin/PC_Dependencies/... //ZhuJiaCheng_test_specify_p4_env/PC_Dependencies/...
            +//depot/Alice2_Bin/Binaries/... //ZhuJiaCheng_test_specify_p4_env/Binaries/...
            +//depot/Alice2_Bin/Engine/... //ZhuJiaCheng_test_specify_p4_env/Engine/...
            +//depot/Alice2_Bin/AliceGame/... //ZhuJiaCheng_test_specify_p4_env/AliceGame/...
            +//depot/Alice2_Bin/*.* //ZhuJiaCheng_test_specify_p4_env/*.*
            +//depot/Alice2_Branches/... //ZhuJiaCheng_test_specify_p4_env/Alice2_Branches/...
            """
            }
        
        expect = {  # already removed unwanted blankspaces and plus/minus sign before each entry.
            "//depot/Alice2_Prog/Development/..."  : "//ZhuJiaCheng_test_specify_p4_env/Development/...", 
            "//depot/Alice2_Prog/Tools/...": "//ZhuJiaCheng_test_specify_p4_env/Tools/...",
            "//depot/Alice2_Bin/PC_Dependencies/...": "//ZhuJiaCheng_test_specify_p4_env/PC_Dependencies/...",
            "//depot/Alice2_Bin/Binaries/...": "//ZhuJiaCheng_test_specify_p4_env/Binaries/...",
            "//depot/Alice2_Bin/Engine/...": "//ZhuJiaCheng_test_specify_p4_env/Engine/...",
            "//depot/Alice2_Bin/AliceGame/...": "//ZhuJiaCheng_test_specify_p4_env/AliceGame/...",
            "//depot/Alice2_Bin/*.*": "//ZhuJiaCheng_test_specify_p4_env/*.*",
            "//depot/Alice2_Branches/...": "//ZhuJiaCheng_test_specify_p4_env/Alice2_Branches/...",
        }
        output = self.ab_agent.parse_p4_view_map( a_view )
        self.assertEqual( output  ,expect )

    def test_path_in_the_workspace(self):
        demo_workspace_basedir = "d:/wksp_test" 
        expected = demo_workspace_basedir + "/" + "Alice2_Branches/Development/Src/a.bat" 
        output = self.ab_agent.path_in_the_workspace(demo_workspace_basedir, "//depot/Alice2_Branches/Development/Src/a.bat", p4env)
        self.assertEqual( output , expected  )
    
    
        
if __name__ == '__main__':   
    unittest.main()
print "ended "

